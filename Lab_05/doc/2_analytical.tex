\chapter{ Аналитический раздел}
\label{cha:analytical}
    В данном разделе будут рассмотрены основные теоритические понятия конвейерной обработки и параллельных вычислений.

    \section{Основные понятия}
        Параллельное программирование служит для создания программ,
        эффективно использующих вычислительные ресурсы за счет одновременного
        исполнения кода на нескольких вычислительных узлах.
        Для создания параллельных приложений используются параллельные языки
        программирования и специализированные системы поддержки параллельного
        программирования, такие как MPI и OpenMP. 
        Параллельное программирование является более сложным по сравнению
        с последовательным как в написании кода, так и в его отладки.
        Для облегчения процесса параллельного программирования существуют
        специализированные инструменты, например, отладчик TotalView \cite{totalview}.

        В модели конвейерной обработки (pipelines) поток обрабатываемых данных проходит через несколько этапов.
        Прохождение этапов осуществляется строго последовательно. 
        Параллелизм достигается за счет одновременной обработки разных элементов на разных этапах.
        Конвейерная обработка возникает при работе с последовательными потоками данных 
        (потоки событий, потоки видеосигналов, потоки изображений), 
        а также при многоэтапной обработке элементов последовательности в строго заданном порядке \cite{typical-models-parallel-applications}.

        Конвейерную обработку можно реализовать с помощью задач и конкурентных очередей.
        Каждая задача реализует этап конвейера, очереди выступают ограниченными буферами,
        накапливающими элементы.

    \section{Проблема ограниченного буфера}
        Рассмотрим проблему ограниченного буфера, известную также как проблема производителя и потребителя.
        Два процесса совместно используют буфер ограниченного размера.
        Один из них, производитель, помещает данные в этот буфер,
        а другой, потребитель, считывает их оттуда.
        Трудности начинаются в тот момент, когда производитель хочет поместить
        в буфер очередную порцию данных и обнаруживает, что буфер полон.
        Для производителя решением является ожидание,
        пока потребитель полностью или частично не очистит буфер.
        Аналогично, если потребитель хочет забрать данные из буфера,
        а буфер пуст, потребитель уходит в состояние ожидания и выходит из него,
        как только производитель положит что-нибудь в буфер и разбудит его.

        Пусть максимальное число элементов в буфере равно N,
        count -- текущее количество элементов в буфере.
        Если значение count равно N, то производитель уходит в состояние ожидания;
        в противном случае производитель помещает данные в буфер и увеличивает значение count.
        Может возникнуть следующая ситуация: буфер пуст, и потребитель только что считал значение перемен­ной count,
        чтобы проверить, не равно ли оно нулю, но квант времени процесса-потребителя закончился.
        Планировщик задач передал управление процессу-производителю,
        который поместил элемент в буфер и увеличил значение count.
        Так как значение было равно 0 и потребитель находиться в состоянии ожидания,
        производитель активизирует его. Но потребитель не был в состоянии ожидания,
        поэтому сигнал активизации про­пал впустую. 
        Когда управление перейдет к потребителю, 
        он обнаружит, что ранее считанное значение count равно нулю и уйдет в состояние ожидания.

        Производитель будет наполнять буфер, пока он не заполнится, после чего перейдёт в состояние ожидания.
        Оба процесса оказались в состоянии ожидания сигнала активации друг от друга (deadlock).
        Причина возникновения deadlock-а состоит в том,
        что сигнал активизации, при­шедший к процессу,
        не находящемуся в состоянии ожидания, пропадает.

        Существует несколько решений проблемы производителя и потребителя. 
        Самым простым является ограничение доступа к переменной 
        count с помощью семафоров \cite{problem-producer-consumer}.  
        
    \section{Вывод}
        В данном разделе были рассмотрены основы конвейерной обработки и технологии параллельного программирования.

\newpage